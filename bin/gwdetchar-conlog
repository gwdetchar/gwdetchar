#!/usr/bin/env python
# coding=utf-8
# Copyright (C) LIGO Scientific Collaboration (2019)
#
# This file is part of the GW DetChar python package.
#
# GW DetChar is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# GW DetChar is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with GW DetChar.  If not, see <http://www.gnu.org/licenses/>.

"""Check whether a list of channel records has changed between two reference
times
"""

import os.path

from gwpy.table import Table

from gwdetchar import (cli, const)
from gwdetchar.io.datafind import downselect

__author__ = 'Alex Urban <alexander.urban@ligo.org>'
__credits__ = 'Andrew Lundgren <andrew.lundgren@ligo.org>, ' \
              'Joshua Smith <joshua.smith@ligo.org>, ' \
              'Duncan Macleod <duncan.macleod@ligo.org>'


# -- parse command line -------------------------------------------------------

parser = cli.create_parser(description=__doc__)
cli.add_gps_start_stop_arguments(parser)
cli.add_ifo_option(parser)
cli.add_frametype_option(parser,
                         help='the frametype name, defaults to second trends '
                              'for the selected interferometer')
cli.add_nproc_option(parser)
parser.add_argument('-o', '--output', default='changes.csv',
                    help='Path to output data file, default: %(default)s')
parser.add_argument('-c', '--channels', default=None, required=False,
                    help="file containing columnar list of channels to "
                         "process, default is to find all relevant channels "
                         "from frames")
parser.add_argument('-s', '--search', nargs='*', default=[],
                    help='process channels matching these regex patterns, '
                         'can be given multiple times, default is to analyze '
                         'all relevant channels from frames')
parser.add_argument('-p', '--preview', default=10, type=int,
                    help='Time (seconds) to test that channel is typically '
                         'kept constant, default: %(default)s')

args = parser.parse_args()

# set up logger
logger = cli.logger(name=os.path.basename(__file__))

# get IFO and frametype
frametype = args.frametype or '{}_T'.format(args.ifo.upper())
preview_time = max(1, args.preview)

# read channel list
if args.channels:
    channels = list(numpy.loadtxt(args.channels, dtype=str, ndmin=1))
    logger.debug('Found {} channels to analyze'.format(len(channels)))

# get list of state changes
logger.info('Determining state changes')
changes, value1, value2, diff = downselect(
    frametype, args.gpsstart, args.gpsend, preview=preview_time,
    channels=channels, search=args.search, dynamic=False, nproc=args.nproc)

# record output
logger.debug('Analysis complete')
table = Table([changes, value1, value2, diff],
              names=('channel', 'initial_value', 'final_value', 'difference'))

# log output
logger.info('The following {0} channels record a state change between {1} '
            'and {2}:\n\n'.format(len(changes), args.gpsstart, args.gpsend))
print(table)
print('\n\n')

# save output
table.write(args.output, overwrite=True)
logger.info('Output written to {}'.format(args.output))
