#!/usr/bin/env python
# coding=utf-8
# Copyright (C) LIGO Scientific Collaboration (2015-)
#
# This file is part of the GW DetChar python package.
#
# GW DetChar is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# GW DetChar is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with GW DetChar.  If not, see <http://www.gnu.org/licenses/>.

"""Compute an Omega scan for a list of channels around a given GPS time

This utility can be used to process an arbitrary list of detector channels
with minimal effort in finding data. The input should be an INI-formatted
configuration file that lists processing options and channels in contextual
blocks, e.g.:

```ini
[GW]
name = Gravitational Wave Strain
q-range = 3.3166,150
frequency-range = 4,2048
resample = 4096
frametype = H1_HOFT_C00
state-flag = H1:DMT-GRD_ISC_LOCK_NOMINAL:1
duration = 64
fftlength = 8
max-mismatch = 0.2
snr-threshold = 5
always-plot = True
plot-time-durations = 1,4,16
channels = H1:GDS-CALIB_STRAIN
```

For more information, see gwdetchar.omega.config.
"""

from __future__ import division

import os
import sys
import numpy
from scipy.signal import butter

from gwpy.utils import gprint
from gwpy.time import to_gps
from gwpy.segments import Segment
from gwpy.signal.qtransform import q_scan

from matplotlib import use
use('agg')  # nopep8

from gwdetchar import (cli, __version__)
from gwdetchar.omega import (config, plot, html)
from gwdetchar.io.datafind import (check_flag, get_data)

__author__ = 'Alex Urban <alexander.urban@ligo.org>'
__credits__ = 'Duncan Macleod <duncan.macleod@ligo.org>'


# -- parse command line -------------------------------------------------------

parser = cli.create_parser(description=__doc__)
parser.add_argument('gpstime', type=to_gps,
                    help='GPS time or datestring to scan')
cli.add_ifo_option(parser, required=False)
parser.add_argument('-o', '--output-directory',
                    help='output directory for the omega scan, '
                         'default: ~/public_html/wdq/{IFO}_{gpstime}')
parser.add_argument('-f', '--config-file', action='append', default=None,
                    help='path to configuration file to use, can be given '
                         'multiple times (files read in order), default: '
                         'choose a standard one based on IFO and GPS time')
parser.add_argument('-s', '--ignore-state-flags', action='store_true',
                    default=False, help='ignore state flag definitions in '
                                        'the configuration, default: False')
parser.add_argument('-t', '--far-threshold', type=float, default=1e-10,
                    help='white noise false alarm rate threshold for '
                         'processing channels, default: %(default)s Hz')
parser.add_argument('-c', '--colormap', default='viridis',
                    help='name of colormap to use, default: %(default)s')
cli.add_nproc_option(parser)
parser.add_argument('-v', '--verbose', action='store_true', default=False,
                    help='print verbose output, default: False')

args = parser.parse_args()

# get run parameters
if args.ifo:
    ifo = args.ifo
else:
    ifo = 'Network'
gps = numpy.around(float(args.gpstime), 3)

print("----------------------------------------------\n"
      "Creating %s omega scan at GPS second %s..." % (ifo, gps))

# get default configuration
if args.config_file is None:
    args.config_file = config.get_default_configuration(ifo, gps)

# parse configuration files
args.config_file = [os.path.abspath(f) for f in args.config_file]
if args.verbose:
    gprint('Parsing the following configuration files:')
    for fname in args.config_file:
        gprint(''.join(['\t', fname]))
cp = config.OmegaConfigParser(ifo=ifo)
cp.read(args.config_file)

# get contextual channel blocks
blocks = cp.get_channel_blocks()

# set up analyzed channel dict
if sys.version_info >= (3, 7):  # python 3.7+
    analyzed = {}
else:
    from collections import OrderedDict
    analyzed = OrderedDict()

# prepare html variables
htmlv = {
    'title': '%s Qscan | %s' % (ifo, gps),
    'config': args.config_file,
    'refresh': True,
}

# set search window
search = Segment(gps - 0.25, gps + 0.25)

# set output directory
outdir = args.output_directory
if outdir is None:
    outdir = os.path.expanduser('~/public_html/wdq/{ifo}_{gps}'.format(
        ifo=ifo, gps=gps))
outdir = os.path.abspath(outdir)
if not os.path.isdir(outdir):
    os.makedirs(outdir)
os.chdir(outdir)
print("Output directory created as %s" % outdir)


# -- Compute Qscan ------------------------------------------------------------

# make subdirectories
plotdir = 'plots'
aboutdir = 'about'
datadir = 'data'
for d in [plotdir, aboutdir, datadir]:
    if not os.path.isdir(d):
        os.makedirs(d)

# set up html output
gprint('Setting up HTML at %s/index.html...' % outdir)
html.write_qscan_page(ifo, gps, analyzed, **htmlv)

# launch omega scans
gprint('Launching Omega scans...')

# range over blocks
for block in blocks.values():
    gprint('Processing block %s' % block.key)
    chans = [c.name for c in block.channels]
    # get configuration
    duration = block.duration
    fftlength = block.fftlength
    pad = max(1, fftlength/4.)
    # check that analysis flag is active for all of `duration`
    if block.flag and not args.ignore_state_flags:
        if args.verbose:
            gprint('Querying state flag %s...' % block.flag)
        if not check_flag(block.flag, gps, duration, pad):
            gprint('%s not active, skipping block' % block.flag)
            continue
    # read in `duration` seconds of data centered on gps
    data = get_data(chans, gps, duration, pad, frametype=block.frametype,
                    source=block.source, nproc=args.nproc,
                    verbose=args.verbose)
    # compute qscans
    for c in block.channels:
        if args.verbose:
            gprint('Computing omega scans for channel %s...' % c.name)

        # get raw timeseries
        series = data[c.name]
        if block.resample:
            series = series.resample(block.resample)

        # filter the timeseries
        corner = c.frange[0] / 1.5
        wn = 2 * corner * series.dt.decompose().value
        hpfilt = butter(12, wn, btype='highpass', analog=False, output='sos')
        hpseries = series.filter(hpfilt, filtfilt=True)
        asd = series.asd(fftlength, fftlength/2, method='lal_median_mean')
        wseries = hpseries.whiten(fftlength, fftlength/2, window='hann',
                                  asd=asd, detrend='linear')

        # crop the timeseries
        wseries = wseries.crop(gps-duration/2, gps+duration/2)
        hpseries = hpseries.crop(gps-duration/2, gps+duration/2)

        # compute eventgrams
        try:
            qgram, far = q_scan(wseries, mismatch=c.mismatch, qrange=c.qrange,
                                frange=c.frange, search=search)
        except:
            if args.verbose:
                gprint('Channel is misbehaved, removing it from the analysis')
            continue
        if (far > args.far_threshold) and (not c.always_plot):
            if args.verbose:
                gprint('Channel not significant at white noise false alarm '
                       'rate %s Hz' % args.far_threshold)
            continue
        Q = qgram.plane.q
        rqgram, _ = q_scan(hpseries, mismatch=c.mismatch, qrange=(Q, Q),
                           frange=qgram.plane.frange, search=search)

        # compute Q-transform spectrograms
        outseg = Segment(gps - max(c.pranges)/2, gps + max(c.pranges)/2)
        tres = min(c.pranges) / 1400
        fres = 700
        qspec = qgram.interpolate(tres=tres, fres=fres, logf=True,
                                  outseg=outseg)
        rqspec = rqgram.interpolate(tres=tres, fres=fres, logf=True,
                                    outseg=outseg)

        # prepare plots
        if args.verbose:
            gprint('Plotting omega scans for channel %s...' % c.name)
        # work out figure size
        for span, png1, png2, png3, png4, png5, png6, png7, png8, png9 in zip(
            c.pranges, c.plots['qscan_whitened'],
            c.plots['qscan_autoscaled'], c.plots['qscan_raw'],
            c.plots['timeseries_raw'], c.plots['timeseries_highpassed'],
            c.plots['timeseries_whitened'], c.plots['eventgram_raw'],
            c.plots['eventgram_whitened'], c.plots['eventgram_autoscaled']
        ):
            # plot whitened qscan
            plot.omega_plot(qspec, gps, span, c.name, str(png1), clim=(0, 25),
                            colormap=args.colormap, figsize=(8, 4.35))
            # plot autoscaled, whitened qscan
            plot.omega_plot(qspec, gps, span, c.name, str(png2),
                            colormap=args.colormap, figsize=(8, 4.35))
            # plot raw qscan
            plot.omega_plot(rqspec, gps, span, c.name, str(png3), clim=(0, 25),
                            colormap=args.colormap, figsize=(8, 4.35))
            # plot raw timeseries
            plot.omega_plot(series, gps, span, c.name, str(png4),
                            ylabel='Amplitude', figsize=(9, 4.5))
            # plot highpassed timeseries
            plot.omega_plot(hpseries, gps, span, c.name, str(png5),
                            ylabel='Highpassed Amplitude', figsize=(9, 4.5))
            # plot whitened timeseries
            plot.omega_plot(wseries, gps, span, c.name, str(png6),
                            ylabel='Whitened Amplitude', figsize=(9, 4.5))
            # plot raw eventgram
            rtable = rqgram.table(snrthresh=c.snrthresh)
            plot.omega_plot(rtable, gps, span, c.name, str(png7), clim=(0, 25),
                            colormap=args.colormap, figsize=(8, 4.35))
            # plot whitened eventgram
            table = qgram.table(snrthresh=c.snrthresh)
            plot.omega_plot(table, gps, span, c.name, str(png8), clim=(0, 25),
                            colormap=args.colormap, figsize=(8, 4.35))
            # plot autoscaled whitened eventgram
            plot.omega_plot(table, gps, span, c.name, str(png9),
                            colormap=args.colormap, figsize=(8, 4.35))

        # save parameters
        c.Q = numpy.around(Q, 1)
        c.energy = numpy.around(qgram.peak['energy'], 1)
        c.snr = numpy.around(qgram.peak['snr'], 1)
        c.t = numpy.around(qgram.peak['time'], 3)
        c.f = numpy.around(qgram.peak['frequency'], 1)

        # update analyzed dict
        try:
            analyzed[c.section]['channels'].append(c)
        except KeyError:
            analyzed[c.section] = {'name': blocks[c.section].name,
                                   'channels': [c]}
        htmlv['toc'] = analyzed

        # update HTML output
        html.write_qscan_page(ifo, gps, analyzed, **htmlv)


# -- Prepare HTML -------------------------------------------------------------

# write HTML page and finish
gprint('Finalizing HTML at %s/index.html...' % outdir)
htmlv['refresh'] = False  # turn off auto-refresh
if analyzed:
    html.write_qscan_page(ifo, gps, analyzed, **htmlv)
else:
    reason = 'No significant channels found during active analysis segments'
    html.write_null_page(ifo, gps, reason, **htmlv)
gprint("-- index.html written, all done --")
