#!/usr/bin/env python
# coding=utf-8
# Copyright (C) LIGO Scientific Collaboration (2015-)
#
# This file is part of the GW DetChar python package.
#
# GW DetChar is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# GW DetChar is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with GW DetChar.  If not, see <http://www.gnu.org/licenses/>.

from __future__ import (division, print_function)

import os
import re
import multiprocessing
import sys

import numpy
%matplotlib inline
from scipy.stats import spearmanr, pearsonr
from scipy.interpolate import UnivariateSpline

from matplotlib import use
use('agg')

from gwpy.timeseries import (TimeSeries, TimeSeriesDict)
from gwpy.time import from_gps
from gwpy.plotter import TimeSeriesPlot
from gwpy.plotter import Plot as gwplot
from gwpy.detector import ChannelList
from gwpy.io import nds as ndsio

from gwdetchar import cli
from gwdetchar.io import html

from sklearn import linear_model, preprocessing, datasets
from sklearn.metrics import mean_squared_error, r2_score

parser = cli.create_parser(
    description=__doc__,
    formatter_class=cli.argparse.ArgumentDefaultsHelpFormatter)
cli.add_gps_start_stop_arguments(parser)
cli.add_ifo_option(parser)
cli.add_nproc_option(parser, default=1)
parser.add_argument('-J', '--nproc-plot', type=int, default=None,
                    help='number of processes to use for plotting')
parser.add_argument('-o', '--output-dir', default=os.curdir,
                    help='output directory for plots')
parser.add_argument('-f', '--channel-file', type=os.path.abspath,
                    help='path for channel file')
parser.add_argument('-T', '--trend-type', default='minute',
                    choices=['second', 'minute'],
                    help='type of trend for correlation')
parser.add_argument('-p', '--primary-channel',
                    default='{ifo}:GDS-CALIB_STRAIN',
                    help='name of primary channel to use')
parser.add_argument('-P', '--primary-frametype',
                    help='frametype for --primary-channel')
parser.add_argument('-r', '--range-channel',
                    default='{ifo}:DMT-SNSH_EFFECTIVE_RANGE_MPC.mean',
                    help='name of range channel to use')
parser.add_argument('-R', '--range-frametype',
                    help='frametype for --range-channel')
parser.add_argument('-O', '--remove-outliers', type=float, default=None,
                    help='Std. dev. limit for removing outliers')
parser.add_argument('-t', '--threshold', type=float, default=0.1, 
                    help='threshold for making a plot')

psig = parser.add_argument_group('Signal processing options')
psig.add_argument('-b', '--band-pass', type=float, nargs=2, default=None,
                  metavar="FLOW FHIGH",
                  help='lower and upper frequencies for bandpass on h(t)')
psig.add_argument('-x', '--filter-padding', type=float, default=3.,
                  help='amount of time (seconds) to pad data for filtering')

args = parser.parse_args()

start = int(args.gpsstart)
end = int(args.gpsend)
pad = args.filter_padding
try:
    flower, fupper = args.band_pass
except TypeError:
    flower, fupper = None

if args.primary_channel == '{ifo}:GDS-CALIB_STRAIN':
    args.primary_frametype = '%s_HOFT_C00' % args.ifo
primary = args.primary_channel.format(ifo=args.ifo)
rangechannel = args.range_channel.format(ifo=args.ifo)

if not os.path.isdir(args.output_dir):
    os.makedirs(args.output_dir)
os.chdir(args.output_dir)
nprocplot = args.nproc_plot or args.nproc

def remove_outliers(ts,N):
    outliers = numpy.nonzero(abs(ts - numpy.mean(ts)) > N*numpy.std(ts))[0]
    c = 1
    if outliers.any():
        print('-- Found %d outliers in %s, recursively removing' % (len(outliers),ts.name))
        while outliers.any():
            cache = outliers
            mask = numpy.ones(len(ts), dtype=bool)
            mask[outliers] = False
            spline = UnivariateSpline(ts[mask].times.value,ts[mask].value,s=0,k=3)
            ts[outliers] = spline(ts[outliers].times.value)
            outliers = numpy.nonzero(abs(ts - numpy.mean(ts)) > N*numpy.std(ts))[0]
            print('Completed %d removal cycles' % c)
            if numpy.array_equal(outliers,cache):
                print('Outliers did not change, breaking recursion')
                break
            print('%d outliers remain' % len(outliers))
            c += 1

# load data
print("-- Loading range data")
rangets = TimeSeries.get(rangechannel, start, end,
                         frametype=args.range_frametype, verbose=True,
                         nproc=args.nproc)

if args.trend_type == 'minute':
    dstart, dend = rangets.span
else:
    dstart = start
    dend = end

print("-- Loading h(t) data")
darmts = TimeSeries.get(primary, dstart-pad, dend+pad, verbose=True,
                        frametype=args.primary_frametype,
                        nproc=args.nproc)

# get darm BLRMS
print("-- Filtering h(t) data")
if args.trend_type == 'minute':
    stride = 60
else:
    stride = 1
if flower:
    darmblrms = (
        darmts.highpass(flower/2., fstop=flower/4., filtfilt=False, ftype='butter').notch(
        60, filtfilt=False).bandpass(
        flower, fupper, fstop=[flower/2., fupper*1.5], filtfilt=False, ftype='butter').crop(
        dstart, dend).rms(stride))
    darmblrms.name = '%s %s-%s Hz BLRMS' % (primary, flower, fupper)
else:
    darmblrms = darmts.notch(60).crop(dstart, dend).rms(stride)
    darmblrms.name = '%s RMS' % primary

if args.remove_outliers:
    print('-- Removing outliers above %f sigma' % args.remove_outliers)
    remove_outliers(darmblrms,args.remove_outliers)
    remove_outliers(rangets,args.remove_outliers)

if args.trend_type == 'minute':
    # calculate the r value between the DARM BLRMS and the Range timeseries
    corr_p = numpy.corrcoef(rangets.value, darmblrms.value)[0, 1]
    # calculate the œÅ value between the DARM BLRMS and the Range timeseries
    corr_s = spearmanr(rangets.value, darmblrms.value)[0]
else:
    # for second trends, set correlation to 0 since sample rates differ
    corr_p = 0
    corr_s = 0
    
# create scaled versions of data to compare to each other
print("-- Creating scaled data")
rangescaled = rangets.detrend()
rangerms = numpy.sqrt(sum(rangescaled**2.0)/len(rangescaled))
darmscaled = darmblrms.detrend()
darmrms = numpy.sqrt(sum(darmscaled**2.0)/len(darmscaled))

#create scaled darm using the rms(range) and the rms(darm)
if args.trend_type == 'minute':
    darmscaled *= (-rangerms / darmrms)

# get aux data
print("-- Loading auxiliary channel data")
host, port = ndsio.host_resolution_order(args.ifo)[0]
if args.channel_file is None:
    channels = ChannelList.query_nds2('*.mean', host=host, port=port,
                                      type='m-trend')
else:
    with open(args.channel_file, 'r') as f:
        channels = f.read().rstrip('\n').split('\n')
nchan = len(channels)
print("Identified %d channels" % nchan)
if args.trend_type == 'minute':
    frametype = '%s_M' % args.ifo # for minute trends
else:
    frametype = '%s_T' % args.ifo # for second trends
auxdata = TimeSeriesDict.get(map(str, channels), dstart, dend, verbose=True,
                             frametype=frametype, nproc=args.nproc,
                             observatory=args.ifo[0], pad=0)

gpsstub = '%d-%d' % (start, end-start)
re_delim = re.compile('[:_-]')
form = '%%.%dd' % len(str(nchan))

print("-- Processing channels")
counter = multiprocessing.Value('i', 0)

p1 = (.1, .1, .9, .95)
p2 = (.1, .15, .9, .9)

def process_channel(input_,):
    chan, ts = input_
    flat = ts.value.min() == ts.value.max()
    if flat:
        corr1 = None
        corr2 = None
        corr1s = None
        corr2s = None
        corr3r = None
        corr3d = None
        plot1 = None
        plot2 = None
        plot3 = None
    else:
        corr1 = numpy.corrcoef(ts.value, darmblrms.value)[0, 1]
        corr1s = spearmanr(ts.value, darmblrms.value)[0]
        corr3r = pearsonr(ts, rangets)[0]
        corr3d = pearsonr(ts, darmblrms)[0]
        
        if args.trend_type == 'minute':
            corr2 = numpy.corrcoef(ts.value, rangets.value)[0, 1]
            corr2s = spearmanr(ts.value, rangets.value)[0]
        else:
            corr2 = 0.0
            corr2s = 0.0
        #if all corralations are below threshold it does not plot
        if((numpy.absolute(corr1) < args.threshold) and (numpy.absolute(corr1s) < args.threshold)
                and (numpy.absolute(corr2) < args.threshold) and (numpy.absolute(corr2s) < args.threshold)):
            plot1 = None
            plot2 = None
            plot3 = None
            return chan, corr1, corr2, corr3r, corr3d, plot1, plot2, plot3, corr1s, corr2s
        plot = TimeSeriesPlot(darmblrms, ts, rangets, sep=True, sharex=True,
                              figsize=(12, 12))
        plot.subplots_adjust(*p1)
        plot.axes[0].set_ylabel('$h(t)$ BLRMS [strain]')
        plot.axes[1].set_ylabel('Channel units')
        plot.axes[2].set_ylabel('Sensitive range [Mpc]')
        for ax in plot.axes:
            ax.legend(loc='best')
            ax.set_xlim(start, end)
            ax.set_epoch(start)
        channelstub = re_delim.sub('_', str(chan)).replace('_', '-', 1)
        plot1 = '%s_TRENDS-%s.png' % (channelstub, gpsstub)
        try:
            plot.save(plot1)
        except (IOError, IndexError):
            plot.save(plot1)
        except RuntimeError as e:
            if 'latex' in str(e).lower():
                plot.save(plot1)
            else:
                raise
        plot.close()

        # plot auto-scaled verions
        tsscaled = ts.detrend()
        tsrms = numpy.sqrt(sum(tsscaled**2.0)/len(tsscaled))
        if args.trend_type == 'minute':
            tsscaled *= (rangerms / tsrms)
            if corr1 > 0:
                tsscaled *= -1
        else:
            tsscaled *= (darmrms / tsrms)
            if corr1 < 0:
                tsscaled *= -1
        plot = TimeSeriesPlot(darmscaled, rangescaled, tsscaled,
                              figsize=[12, 6])
        plot.subplots_adjust(*p2)
        ax = plot.gca()
        ax.set_xlim(start, end)
        ax.set_epoch(start)
        ax.set_ylabel('Scaled amplitude [arbitrary units]')
        ax.legend(loc='best')
        plot2 = '%s_COMPARISON-%s.png' % (channelstub, gpsstub)
        try:
            plot.save(plot2)
        except (IOError, IndexError):
            plot.save(plot2)
        except RuntimeError as e:
            if 'latex' in str(e).lower():
                plot.save(plot2)
            else:
                raise
        plot.close()
        
        #plot scatter plots
        rangeColor="red"
        darmblrmsColor="blue"
        plotHeight=10
        plotWidth=20

        tsCopy=ts.reshape(-1,1)
        rangetsCopy=rangets.reshape(-1,1)
        darmblrmsCopy=darmblrms.reshape(-1,1)

        rangeReg = linear_model.LinearRegression()
        rangeReg.fit(tsCopy, rangetsCopy)
        rangeFit = rangeReg.predict(tsCopy)
        
        darblrmsReg = linear_model.LinearRegression()
        darblrmsReg.fit(tsCopy, darmblrmsCopy)
        darblrmsFit = darmblrmsReg.predict(tsCopy)

        scatPlot=gwplot()

        scatPlot.add_subplot(121)
        axes = scatPlot.gca()
        axes.set_xlabel(ts.name.replace("_","\_"))
        axes.set_ylabel(rangets.name.replace("_","\_")+" [Mpc]")
        axes.set_xlabel(ts.name.replace("_","\_"))
        axes.set_ylabel(range.name.replace("_","\_")+" [Mpc]")
        axes.text(.9,.1,"r = " + str('{0:.2}'.format(corr3r), verticalalignment='bottom', horizontalalignment='right',
            transform=axes.transAxes, color="black", size=30)
        scatPlot.add_scatter(ts, rangets, color=rangeColor)
        scatPlot.add_line(ts, rangeFit, color="black")
        scatPlot.set_figheight(plotHeight)
        scatPlot.set_figwidth(plotWidth)

        scatPlot.add_subplot(122)
        axes = scatPlot.gca()
        axes.set_xlabel(ts.name.replace("_","\_"))
        axes.set_ylabel(darmblrms.name.replace("_","\_")+" [strain]")
        axes.set_xlabel(ts.name.replace("_","\_"))
        axes.set_ylabel(darmblrms.name.replace("_","\_")+" [strain]")
        axes.text(.9,.1,"r = " + str('{0:.2}'.format(corr3d), verticalalignment='bottom', horizontalalignment='right',
            transform=axes.transAxes, color="black", size=30)
        scatPlot.add_scatter(ts, darmblrms, color=darmblrmsColor)
        scatPlot.add_line(ts, darmblrmsFit, color="black")
        scatPlot.set_figheight(plotHeight)
        scatPlot.set_figwidth(plotWidth)
        
        plot3 = '%s_SCATTER-%s.png' % (channelstub, gpsstub)
        try:
            scatPlot.save(plot3)
        except (IOError, IndexError):
            scatPlot.save(plot3)
        except RuntimeError as e:
            if 'latex' in str(e).lower():
                scatPlot.save(plot3)
            else:
                raise

        scatPlot.close()

    # increment counter and print status
    with counter.get_lock():
        counter.value += 1
        pc = 100 * counter.value / nchan
        print("Completed [%d/%d] %3d%% %-50s"
              % (counter.value, nchan, pc, '(%s)' % str(chan)), end='\r')
        sys.stdout.flush()
    return chan, corr1, corr2, corr3r, corr3d, plot1, plot2, plot3, corr1s, corr2s

pool = multiprocessing.Pool(nprocplot)
results = pool.map(process_channel, auxdata.iteritems())
results.sort(key=lambda x: (x[1] is not None and max(abs(x[1]),abs(x[2]),
             abs(x[5]),abs(x[6])) or 0, x[0]), reverse=True)
rhos = numpy.asarray([x[1] for x in results if x is not None])

print("")

with open('results.txt', 'w') as f:
    for ch, corr1, corr2, corr3r, corr3d, _, _, corr1s, corr2s in results:
        print('%s %s %s %s %s %s %s' % (ch, corr1, corr2, corr3r, corr3d, corr1s, corr2s), file=f)

# -- write html
title = '%s slow correlations: %d-%d' % (args.ifo, start, end)
page = html.new_bootstrap_page(title=title)
page.div(class_='container')

# header
if flower:
    pstr = '<code>%s</code> (band-limited %s-%s Hz)' % (primary, flower, fupper)
else:
    pstr = primary
if args.trend_type == 'minute':
    pstr += ' and <code>%s</code>' % rangechannel
page.div(class_='page-header')
page.h1(title)
page.p("This analysis searched %d channels for linear correlations with %s"
       % (nchan, pstr))
page.div.close()

# results
page.h2('Results')
r_blrms = "<i>r<sub>blrms</sub> </i>"
r_range = "<i>r<sub>range</sub> </i>"
r = "<i>r</i>"
rho_blrms = "<i>&rho;<sub>blrms</sub> </i>"
rho_range = "<i>&rho;<sub>range</sub> </i>"
rho = "<i>&rho;</i>"
Pearson_wikilink = html.markup.oneliner.a(
    "Pearson's correlation coefficient",
    href="https://en.wikipedia.org/wiki/"
         "Pearson_product-moment_correlation_coefficient",
    rel="external")
numpylink = html.markup.oneliner.a(
    "<code>numpy.corrcoef</code>",
    href="http://docs.scipy.org/doc/numpy-1.10.1/reference/generated/"
         "numpy.corrcoef.html",
    rel="external")
Spearman_wikilink = html.markup.oneliner.a(
    "Spearman's correlation coefficient",
    href="https://en.wikipedia.org/wiki/"
         "Spearman%27s_rank_correlation_coefficient",
    rel="external")
scipylink = html.markup.oneliner.a(
    "<code>scipy.stats.spearmanr</code>",
    href="http://docs.scipy.org/doc/scipy-0.14.0/reference/generated/"
         "scipy.stats.spearmanr.html",
    rel="external")
page.p("In the results below, all %s values are calculated as the square of %s using %s"
"and all %s values are calculated as the square of %s using %s."
       % (r, Pearson_wikilink, numpylink, rho, Spearman_wikilink, scipylink))
if args.trend_type == 'minute':
    page.p("%s and %s are reported for <code>%s</code>. %s and %s are reported for"
    "<code>%s</code>. The %s between these two channels is %.2f."
    "The %s between these two channels is %.2f."
        % (r_blrms, rho_blrms, primary, r_range, rho_range, rangechannel, r, corr_p, rho, corr_s))
    
page.div(class_='panel-group', id_='results')
for i, (ch, corr1, corr2, corr3r, corr3d, plot1, plot2, plot3, corr1s, corr2s) in enumerate(results):
    if corr1 is None:
        h = '%s [flat]' % ch
    elif plot1 is None:
        h = '%s [%s = %.2f, %s = %.2f] [%s = %.2f, %s = %.2f] [below threshold]' % (ch, r_blrms, corr1,
        r_range, corr2, rho_blrms, corr1s, rho_range, corr2s)
    elif args.trend_type == 'minute':
        h = '%s [%s = %.2f, %s = %.2f] [%s = %.2f, %s = %.2f]' % (ch, r_blrms, corr1,
        r_range, corr2, rho_blrms, corr1s, rho_range, corr2s)
    else:
        h = '%s [%s = %.2f]' % (ch, r_blrms, corr1)
    if (corr1 is None) or (corr1 == 0) or (plot1 is None):
        context = 'panel-default'
    elif((numpy.absolute(corr1) >= .6) or (numpy.absolute(corr1s) >= .6)
          or (numpy.absolute(corr2) >= .6) or (numpy.absolute(corr2s) >= .6)):
        context = 'panel-danger'
    elif((numpy.absolute(corr1) >= .4) or (numpy.absolute(corr1s) >= .4)
          or (numpy.absolute(corr2) >= .4) or (numpy.absolute(corr2s) >= .4)):
        context = 'panel-warning'
    else:
        context = 'panel-info'
    page.div(class_='panel %s' % context)
    # heading
    page.div(class_='panel-heading')
    page.a(h, class_='panel-title', href='#channel%d' % i,
           **{'data-toggle': 'collapse', 'data-parent': '#results'})
    page.div.close()
    # body
    page.div(id_='channel%d' % i, class_='panel-collapse collapse')
    page.div(class_='panel-body')
    if corr1 is None:
        page.p("The amplitude data for this channel is flat (does not change) for the chosen time period.")
    elif plot1 is None:
        page.p("Niether r or rho are above the threshold of %.2f." %(args.threshold))
    else:
        for p in (plot1, plot2, plot3):
            page.a(href=p, target='_blank')
            page.img(class_='img-responsive', src=p)
            page.a.close()
    page.div.close()  # panel-body
    page.div.close()  # panel-collapse
    page.div.close()  # panel
page.div.close()  # panel-group

# params
def write_param(param, value):
    page.p()
    page.strong('%s: ' % param)
    page.add(str(value))
    page.p.close()

page.h2('Parameters')
page.p('This analysis used the following parameters:')
write_param('Start time', '%s (%d)' % (from_gps(start), start))
write_param('End time', '%s (%d)' % (from_gps(end), end))
write_param('Primary channel',
            '%s (%s)' % (primary, args.primary_frametype.format(ifo=args.ifo)))
write_param('Range channel',
            '%s (%s)' % (rangechannel, args.range_frametype or '-'))
write_param('Band-pass', '%s-%s' % (flower, fupper))

page.div.close()  # container
with open('index.html', 'w') as f:
    print(str(page), file=f)

print ("-- Process Completed")
